/*
 * Copyright (c) 2024, codex
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package codex.renthyl;

import codex.renthyl.asset.FrameGraphKey;
import codex.renthyl.client.GraphSetting;
import codex.renthyl.client.GraphSource;
import codex.renthyl.debug.GraphEventCapture;
import codex.renthyl.export.FrameGraphData;
import codex.renthyl.export.ModuleGraphData;
import codex.renthyl.modules.ModuleLocator;
import codex.renthyl.modules.RenderContainer;
import codex.renthyl.modules.RenderModule;
import codex.renthyl.modules.RenderPass;
import codex.renthyl.modules.RenderThread;
import com.jme3.asset.AssetManager;
import com.jme3.export.SavableObject;
import com.jme3.opencl.CommandQueue;
import com.jme3.opencl.Context;
import com.jme3.renderer.RenderManager;
import com.jme3.renderer.RendererException;
import com.jme3.renderer.pipeline.RenderPipeline;
import com.jme3.renderer.ViewPort;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.function.Function;
import java.util.logging.Logger;

/**
 * Manages render passes, dependencies, and resources in a node-based parameter system.
 * <p>
 * Rendering is a complicated task, involving many parameters and resources. The framegraph
 * aims to simplify rendering from the user's perspective, and limit the creation, binding,
 * and destruction of resources wherever possible.
 * <p>
 * Passes are expected to declare and describe beforehand the resources they plan on using
 * during execution. Passes can also reference resources declared by other passes. The resource
 * manager can determine from these "promises" which passes can be culled, as their contributions
 * would ultimately go unused.
 * <p>
 * During execution, passes expected ask the resource manager for the resource the declared or referenced
 * earlier. If the resource does not already exist (is virtual) the manager will either create a new
 * resource or allocate an existing, unused resource that qualifies based on the description provided
 * on declaration. Reallocation is usually preferred to reduce memory footprint.
 * <p>
 * FrameGraph execution occurs in four steps:
 * <ol>
 *  <li><strong>Preparation.</strong> Passes declare, reserve, and reference resources
 * during this step.</li>
 *  <li><strong>Culling.</strong> The resource manager determines which resources and
 * passes are unused, and culls them. This can often save loads of resources, as many
 * passes may not used for large parts of the application.</li>
 *  <li><strong>Execution.</strong> Passes that were not culled acquire the resources
 * they need, and perform rendering operations. All passes are expected to release
 * all resources they declared or referenced in the first step, however, this is done
 * automatically by {@link RenderPass}.</li>
 *  <li><strong>Reset.</strong> Passes perform whatever post-rendering cleanup is necessary.</li>
 * </ol>
 * <p>
 * Each step begins only after every qualifying pass has completed the previous step.
 * <p>
 * Passes are executed in the order they appear in the queue. This can sometimes lead
 * to unintended consequences, as a pass may use resources generated by a later queue.
 * 
 * @author codex
 */
public class FrameGraph implements RenderPipeline<FGPipelineContext> {
    
    private static final Logger LOG = Logger.getLogger(FrameGraph.class.getName());
    private static final long THREAD_WAIT_TIMEOUT = 5000;
    public static final Class<FGPipelineContext> CONTEXT_TYPE = FGPipelineContext.class;
    
    private final AssetManager assetManager;
    private final ResourceList resources;
    private final ExecutionQueueList executionQueues;
    private final FGRenderContext context;
    private final HashMap<String, Object> settings = new HashMap<>();
    private RenderThread root;
    private String name = "FrameGraph";
    private String docAsset = null;
    private boolean dynamic = false;
    private boolean layoutUpdateNeeded = true;
    private boolean rendered = false;
    private boolean debugPrint = false;
    private int nextModuleId = 0;
    
    /**
     * Creates a new blank framegraph.
     * 
     * @param assetManager asset manager (not null)
     */
    public FrameGraph(AssetManager assetManager) {
        this.assetManager = assetManager;
        this.resources = new ResourceList(this);
        this.executionQueues = new ExecutionQueueList();
        this.context = new FGRenderContext(this);
        this.root = new RenderThread(MainThreadIndexSource.INSTANCE);
        this.root.initializeModule(this);
    }
    /**
     * Creates a new framegraph from the given data.
     * 
     * @param assetManager
     * @param data 
     */
    public FrameGraph(AssetManager assetManager, FrameGraphData data) {
        this(assetManager);
        applyData(data);
    }
    /**
     * Creates a new framegraph from data obtained by the given asset key.
     * 
     * @param assetManager
     * @param key 
     */
    public FrameGraph(AssetManager assetManager, FrameGraphKey key) {
        this(assetManager, assetManager.loadAsset(key));
    }
    /**
     * Creates a new framegraph from data obtained by the given asset name.
     * 
     * @param assetManager
     * @param dataAsset 
     */
    public FrameGraph(AssetManager assetManager, String dataAsset) {
        this(assetManager, assetManager.loadAsset(new FrameGraphKey(dataAsset)));
    }
    
    @Override
    public FGPipelineContext fetchPipelineContext(RenderManager rm) {
        return rm.getContext(CONTEXT_TYPE);
    }
    @Override
    public void startRenderFrame(RenderManager rm) {
        Renthyl.requireInitialized();
    }
    @Override
    public void pipelineRender(RenderManager rm, FGPipelineContext pContext, ViewPort vp, float tpf) {
        
        boolean updateNeeded = dynamic || layoutUpdateNeeded;
        ExecutionThreadManager threadManager = pContext.getThreadManager();
        GraphEventCapture cap = context.getGraphCapture();
        if (threadManager.didErrorOccur()) {
            return;
        }
        
        // prepare
        rm.applyViewPort(vp);
        context.target(rm, pContext, vp, tpf);
        if (cap != null) {
            cap.renderViewPort(context.getViewPort());
        }
        if (!rendered) {
            resources.beginRenderFrame(pContext.getRenderObjects(), pContext.getEventCapture());
        }
        if (updateNeeded) {
            executionQueues.flush();
            root.queueModule(context, executionQueues, ModuleIndex.MAIN_THREAD);
        }
        root.prepareModuleRender(context);
        resources.applyFutureReferences();
        
        // cull modules and resources
        if (updateNeeded) {
            root.countReferences();
            resources.cullUnreferenced();
            layoutUpdateNeeded = false;
        }
        
        // execute
        context.pushRenderSettings();
        threadManager.start(context, executionQueues);
        waitForActiveThreads(pContext.getThreadManager(), THREAD_WAIT_TIMEOUT);
        if (threadManager.didErrorOccur()) {
            throw new RendererException("FrameGraph render incomplete.");
        }
        
        // reset
        context.popFrameBuffer();
        root.resetModuleRender(context);
        pContext.getRenderObjects().clearReservations();
        resources.clear();
        rm.getRenderer().clearClipRect();
        
        rendered = true;
        
    }
    @Override
    public boolean hasRenderedThisFrame() {
        return rendered;
    }
    @Override
    public void endRenderFrame(RenderManager rm) {
        root.renderingComplete();
        rendered = false;
    }
    @Override
    public String toString() {
        return "FrameGraph ("+name+")";
    }
    
    private void waitForActiveThreads(ExecutionThreadManager threads, long timeout) {
        if (threads.getNumActiveThreads() > 0) {
            long start = System.currentTimeMillis();
            while (threads.getNumActiveThreads() > 0) {
                if (System.currentTimeMillis()-start > timeout) {
                    throw new RendererException("Timed out waiting for "
                            + threads.getNumActiveThreads() + " threads to complete.");
                }
            }
        }
    }
    
    /**
     * Adds the pass to end of the {@link PassThread} running on the main render thread.
     * 
     * @param <T>
     * @param module
     * @return given pass
     */
    public <T extends RenderModule> T add(T module) {
        root.add(module);
        return module;
    }
    /**
     * Adds the pass at the index.
     * <p>
     * If the thread index is &gt;= the total number of {@link PassThreads}s,
     * a new PassThread will be created for this to be added to.
     * <p>
     * If the queue index is &gt;= the current queue size, the pass will
     * be added to the end of the queue. Passes above the added pass
     * will have their indexes shifted.
     * 
     * @param <T>
     * @param module
     * @param index
     * @return 
     */
    public <T extends RenderModule> T add(T module, int index) {
        root.add(module, index);
        return module;
    }
    /**
     * Adds the pass to end of the {@link PassThread} running on the main render thread.
     * 
     * @param <T>
     * @param module
     * @param name name to be assigned to the module
     * @return given pass
     */
    public <T extends RenderModule> T add(T module, String name) {
        root.add(module);
        module.setName(name);
        return module;
    }
    /**
     * Adds the pass at the index.
     * <p>
     * If the thread index is &gt;= the total number of {@link PassThreads}s,
     * a new PassThread will be created for this to be added to.
     * <p>
     * If the queue index is &gt;= the current queue size, the pass will
     * be added to the end of the queue. Passes above the added pass
     * will have their indexes shifted.
     * 
     * @param <T>
     * @param module
     * @param index
     * @param name name to be assigned to the module
     * @return 
     */
    public <T extends RenderModule> T add(T module, int index, String name) {
        root.add(module, index);
        module.setName(name);
        return module;
    }
    
    /**
     * Adds an array of passes connected in series to the framegraph.
     * <p>
     * The named input ticket on each pass (except the first) is connected to
     * the named output ticket on the previous pass, creating a series of connected
     * passes. The array length determines the number of passes that will be added
     * and connected.
     * <p>
     * Null elements of the array are replaced using the Function.
     * 
     * @param <T>
     * @param array array of passes (elements may be null)
     * @param factory creates passes where array elements are null (may be null)
     * @param inTicket name of the input ticket on each pass
     * @param outTicket name of the output ticket on each pass
     * @return array of passes
     * @see PassThread#addLoop(T[], int, java.util.function.Supplier, java.lang.String, java.lang.String)
     */
    public <T extends RenderModule> T[] addLoop(T[] array, Function<Integer, T> factory,
            String inTicket, String outTicket) {
        root.addLoop(array, -1, factory, inTicket, outTicket);
        return array;
    }
    /**
     * Adds an array of passes connected in series to the framegraph.
     * <p>
     * The named input ticket on each pass (except the first) is connected to
     * the named output ticket on the previous pass.
     * 
     * @param <T>
     * @param array array of passes (elements may be null)
     * @param index index that passes are added to
     * @param function creates passes where array elements are null (may be null)
     * @param inTicket name of the input ticket on each pass
     * @param outTicket name of the output ticket on each pass
     * @return array of passes
     * @see PassThread#addLoop(T[], int, java.util.function.Supplier, java.lang.String, java.lang.String)
     */
    public <T extends RenderModule> T[] addLoop(T[] array, int index,
            Function<Integer, T> function, String inTicket, String outTicket) {
        root.addLoop(array, index, function, inTicket, outTicket);
        return array;
    }
    
    /**
     * Gets the first pass that qualifies.
     * 
     * @param <T>
     * @param by
     * @return first qualifying pass, or null
     */
    public <T extends RenderModule> T get(ModuleLocator<T> by) {
        return (T)root.get(by);
    }
    
    /**
     * Registers the object under the name in the settings map.
     * <p>
     * Registered objects can be referenced by passes by name. Any existing
     * object already registered under the name will be replaced.
     * 
     * @param <T>
     * @param name
     * @param object
     * @return given object
     */
    public <T> T setSetting(String name, T object) {
        settings.put(name, object);
        return object;
    }
    /**
     * Registers the object under the name in the settings map, and creates
     * a {@link GraphSetting} with the same name.
     * 
     * @param <T>
     * @param name
     * @param object
     * @param defaultValue
     * @param create true to create a GraphSetting, otherwise one will not be created and null returned
     * @return created graph setting
     * @see #setSetting(java.lang.String, java.lang.Object)
     */
    public <T> GraphSetting<T> setSetting(String name, T object, T defaultValue) {
        setSetting(name, object);
        return new GraphSetting<>(name, defaultValue);
    }
    /**
     * Sets an integer in the settings map based on a boolean value.
     * <p>
     * If the boolean is true, 0 is written, otherwise -1 is written. Commonly
     * used to enable/disable features by switching a Junction to 0 or -1.
     * 
     * @param name
     * @param enable
     * @return 
     * @see #setSetting(java.lang.String, java.lang.Object)
     */
    public int enableFeature(String name, boolean enable) {
        return setSetting(name, enable ? 0 : -1);
    }
    /**
     * Enables the named feature if it is disabled, and vise versa.
     * 
     * @param name
     * @return 
     */
    public boolean toggleFeature(String name) {
        return enableFeature(name, !isFeatureEnabled(name)) == 0;
    }
    /**
     * Gets the object registered under the name in the settings map,
     * or null if none is registered.
     * 
     * @param <T>
     * @param name
     * @return registered object, or null
     */
    public <T> T getSetting(String name) {
        Object obj = settings.get(name);
        if (obj != null) {
            return (T)obj;
        } else {
            return null;
        }
    }
    /**
     * Gets the object of the type registered under the name in
     * the settings map.
     * 
     * @param <T>
     * @param name
     * @param type
     * @return 
     */
    public <T> T getSetting(String name, Class<T> type) {
        Object obj = settings.get(name);
        if (obj != null && type.isAssignableFrom(obj.getClass())) {
            return (T)obj;
        } else {
            return null;
        }
    }
    /**
     * Returns true if the named feature is enabled.
     * 
     * @param name
     * @return 
     */
    public boolean isFeatureEnabled(String name) {
        Integer feature = getSetting(name, Integer.class);
        return feature != null && feature == 0;
    }
    /**
     * Removes the object registered under the name in the settings map.
     * 
     * @param <T>
     * @param name
     * @return removed object, or null
     */
    public <T> T removeSetting(String name) {
        Object obj = settings.remove(name);
        if (obj != null) {
            return (T)obj;
        } else {
            return null;
        }
    }
    /**
     * Gets the settings map.
     * <p>
     * The returned map may be modified.
     * 
     * @return 
     */
    public HashMap<String, Object> getSettingsMap() {
        return settings;
    }
    
    /**
     * Indicates that the layout of the framegraph has changed and
     * an update is necessary before rendering.
     */
    public void setLayoutUpdateNeeded() {
        layoutUpdateNeeded = true;
    }
    
    /**
     * Sets the name of this FrameGraph.
     * 
     * @param name 
     */
    public void setName(String name) {
        this.name = name;
    }
    /**
     * Sets layout updates as dynamic, so specifically setting
     * an update flag is not necessary.
     * <p>
     * default=false
     * 
     * @param dynamic 
     */
    public void setDynamic(boolean dynamic) {
        this.dynamic = dynamic;
    }
    /**
     * Sets the asset path corresponding to a documentation file for
     * this FrameGraph.
     * 
     * @param docs asset path, or null for no documentation
     */
    public void setDocumentationAsset(String docs) {
        this.docAsset = docs;
    }
    /**
     * Sets the OpenCL context used for compute shading.
     * 
     * @param clContext 
     */
    public void setCLContext(Context clContext) {
        context.setCLContext(clContext);
    }
    /**
     * Assigns this framegraph to the OpenCL command queue.
     * <p>
     * Passes do not need to use the assigned command queue, but are encouraged to.
     * 
     * @param clQueue 
     */
    public void setCLQueue(CommandQueue clQueue) {
        context.setCLQueue(clQueue);
    }
    /**
     * Enables printing of information useful for debugging.
     * <p>
     * default=false
     * 
     * @param debugPrint 
     */
    public void enableDebugPrint(boolean debugPrint) {
        this.debugPrint = debugPrint;
    }
    
    public RenderContainer getRoot() {
        return root;
    }
    /**
     * Gets the {@link AssetManager} assigned to this FrameGraph.
     * 
     * @return 
     */
    public AssetManager getAssetManager() {
        return assetManager;
    }
    /**
     * Gets the {@link ResourceList} that manages resources for this FrameGraph.
     * 
     * @return 
     */
    public ResourceList getResources() {
        return resources;
    }
    /**
     * Gets the rendering context.
     * 
     * @return 
     */
    public FGRenderContext getContext() {
        return context;
    }
    /**
     * Gets the RenderManager.
     * 
     * @return 
     */
    public RenderManager getRenderManager() {
        return context.getRenderManager();
    }
    /**
     * Gets the OpenCL context used for compute shading, or null if not set.
     * 
     * @return 
     */
    public Context getCLContext() {
        return context.getCLContext();
    }
    /**
     * Gets the name of this framegraph.
     * 
     * @return 
     */
    public String getName() {
        return name;
    }
    /**
     * Returns an asset path corresponding to a documentation file for
     * this FrameGraph.
     * 
     * @return asset path, or null if no documentation is available
     */
    public String getDocumantationAsset() {
        return docAsset;
    }
    /**
     * 
     * @return 
     */
    public boolean isDynamic() {
        return dynamic;
    }
    /**
     * 
     * @return 
     */
    public boolean isLayoutUpdateNeeded() {
        return layoutUpdateNeeded;
    }
    /**
     * Returns true if this framegraph is running asynchronous {@link PassThread}s.
     * 
     * @return 
     */
    public boolean isAsync() {
        return executionQueues.getNumActiveQueues() > 1;
    }
    /**
     * 
     * @return 
     */
    public boolean isDebugPrintEnabled() {
        return debugPrint;
    }
    
    /**
     * Applies the {@link FrameGraphData} to this FrameGraph.
     * 
     * @param data
     * @return 
     */
    public final FrameGraph applyData(FrameGraphData data) {
        name = data.getName();
        for (SavableObject obj : data.getSettings()) {
            setSetting(obj.getName(), obj.getObject());
        }
        return applyData(data.getModules());
    }
    /**
     * Applies the {@link ModuleGraphData} to this FrameGraph.
     * 
     * @param data
     * @return this instance
     * @throws IllegalStateException if the tree root is already a member of a FrameGraph
     */
    public final FrameGraph applyData(ModuleGraphData data) {
        if (root != null) {
            root.cleanupModule();
        }
        root = data.getRootModule(RenderThread.class);
        if (root.isAssigned()) {
            throw new IllegalStateException("Cannot apply module root that is already a member of a FrameGraph.");
        }
        root.setThreadIndexSource(MainThreadIndexSource.INSTANCE);
        root.initializeModule(this);
        setLayoutUpdateNeeded();
        return this;
    }
    /**
     * Applies the {@link ModuleGraphData} to this FrameGraph.
     * 
     * @param data
     * @return this instance
     * @throws ClassCastException if the object is not an instance of {@link ModuleGraphData}.
     * @throws NullPointerException if the object is null
     */
    public FrameGraph applyData(Object data) {
        if (data != null) {
            if (data instanceof FrameGraphData) {
                return applyData((FrameGraphData)data);
            } else if (data instanceof ModuleGraphData) {
                return applyData((ModuleGraphData)data);
            } else {
                throw new ClassCastException(data.getClass()+" cannot be accepted as usable data.");
            }
        } else {
            throw new NullPointerException("Data cannot be null.");
        }
    }
    /**
     * Loads and applies {@link ModuleGraphData} from the key.
     * 
     * @param key
     * @return 
     */
    public FrameGraph loadData(FrameGraphKey key) {
        return applyData(assetManager.loadAsset(key));
    }
    /**
     * Loads and applies {@link ModuleGraphData} at the specified asset path.
     * 
     * @param assetPath
     * @return 
     */
    public FrameGraph loadData(String assetPath) {
        return applyData(assetManager.loadAsset(new FrameGraphKey(assetPath)));
    }
    /**
     * Creates an exportable version of this FrameGraph as {@link FrameGraphData}.
     * 
     * @return 
     */
    public FrameGraphData createData() {
        return new FrameGraphData(this);
    }
    /**
     * Creates exportable version of this FrameGraph as {@link ModuleGraphData}.
     * 
     * @return 
     */
    public ModuleGraphData createModuleData() {
        return new ModuleGraphData(root);
    }
    
    /**
     * Returns the next unique module id for this FrameGraph.
     * 
     * @return 
     */
    public final int getNextId() {
        return nextModuleId++;
    }
    
    private static final class MainThreadIndexSource implements GraphSource<Integer> {

        public static final MainThreadIndexSource INSTANCE = new MainThreadIndexSource();
        
        @Override
        public Integer getGraphValue(FrameGraph frameGraph, ViewPort viewPort) {
            return ModuleIndex.MAIN_THREAD;
        }
        
    }
    
}
